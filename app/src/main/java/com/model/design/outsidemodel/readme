/**名称*/
外观模式

/**定义*/
要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用

/**应用场景*/
·为一个复杂的子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化
·使用外观模式可以将一个子系统和使用它的客户端以及其它的子系统分离开来，这就提高了子系统的独立性和可移植性
·在构建一个层次化结构的时候，可以使用外观模式定义每一个层次对外交互的接口。这样，层与层之间只需要通过外观进行通信，
从而简化层与层之间的依赖关系

/**优点*/
·降低了客户端与子系统类的耦合度，实现了子系统与客户之间的松耦合关系
·外观类对子系统的接口封装，使得系统更易于使用
·提高灵活性，不管子系统如何变化，只要不影响门面对象，就可以自由修改

/**缺点*/
·增加新的子系统可能需要修改外观类的源代码，违背了“开闭原则”
·所有子系统的功能都通过一个接口来提供，这个接口可能会变得很复杂

/**源码分析*/
外观模式在Android中应用也非常广泛，比如Context类，里面封装了很多方法，还是以startActivity()方法为例。
实际上startActivity()是通过ActivityManagerService来实现的，ActivityManagerService我们应该都有耳闻，
但是实际开发中一般都用不到，通过封装的方式，Context类隐藏了这些细节，我们只要简单调个方法就可以启动一个新的Activity

