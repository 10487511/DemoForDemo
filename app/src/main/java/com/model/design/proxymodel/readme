/**名称*/
代理模式

/**定义*/
为其他对象提供一种代理以控制这个对象的访问

/**应用场景*/
·当一个对象不能或者不想直接访问另一个对象时，可以通过一个代理对象来间接访问。为保证客户端使用的透明性，委托对象和代理对象要实现同样的接口
·被访问的对象不想暴露全部内容时，可以通过代理去掉不想被访问的内容
·根据适用范围，代理模式可以分为以下几种：
    ·远程代理：为一个对象在不同的地址空间提供局部代表，这样系统可以将Server部分的事项隐藏
    ·虚拟代理：如果要创建一个资源消耗较大的对象，可以先用一个代理对象表示，在真正需要的时候才真正创建
    ·保护代理：用代理对象控制对一个对象的访问，给不同的用户提供不同的访问权限
    ·智能引用：在引用原始对象的时候附加额外操作，并对指向原始对象的引用增加引用计数

/**优点*/
·代理作为调用者和真实主题的中间层,降低了模块间和系统的耦合性
·可以以一个小对象代理一个大对象,达到优化系统提高运行速度的目的
·代理对象能够控制调用者的访问权限，起到了保护真实主题的作用

/**缺点*/
·由于在调用者和真实主题之间增加了代理对象，因此可能会造成请求的处理速度变慢
·实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度

/**源码分析*/
ActivityManagerProxy

/**注意*/
从代码的角度来分，代理可以分为两种：一种是静态代理，另一种是动态代理
·静态代理就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。上面的例子实现就是静态代理
·动态代理类的源码是在程序运行期间根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定